# CritterChain: Governance Pallets - Runtime Configuration Recipe

This document provides a detailed "recipe" for integrating and configuring key FRAME governance pallets into the CritterChain runtime (`runtime/src/lib.rs`). It builds upon the concepts outlined in `GOVERNANCE.md`.

**Assumptions:**
*   Core runtime types like `AccountId`, `Balance`, `BlockNumber`, `RuntimeOrigin`, `RuntimeCall`, `RuntimeEvent` are defined.
*   `pallet-balances` is used for `Currency`.
*   `pallet-timestamp` provides `UnixTime`.
*   The runtime uses `frame_system::EnsureRoot<AccountId>` as a root origin.
*   `PTCN` is a constant representing the smallest unit of the native token (e.g., `1_000_000_000_000` for 12 decimals).
*   Constants like `MILLISECS_PER_BLOCK`, `SLOT_DURATION` are defined. Time-based constants like `DAYS`, `HOURS` are derived from these (e.g., `pub const HOURS: BlockNumber = 60 * 60 * 1000 / MILLISECS_PER_BLOCK;`).

## 1. Overview of Governance Pallets

CritterChain's on-chain governance will initially be composed of:
*   **`pallet-scheduler`**: Often a prerequisite for `pallet-democracy` to schedule proposal enactments.
*   **`pallet-preimage`**: (Optional but recommended) For storing proposal preimages, especially for large proposals, to keep `pallet-democracy` storage lighter.
*   **`pallet-democracy`**: For public referenda on proposals.
*   **`pallet-collective` (Instance1: TechnicalCouncil)**: A council of elected members to manage certain operations, fast-track proposals, or act as a technical committee.
*   **`pallet_elections_phragmen`**: For electing members to the Technical Council. (A simpler `pallet-membership` could be used for an earlier MVP phase if elections are too complex initially).
*   **`pallet-treasury`**: For managing on-chain funds collected from various sources (e.g., marketplace fees, part of staking rewards/slashes, breeding fees) and disbursing them based on proposals.

## 2. `Cargo.toml` Dependencies (Runtime)

Ensure the runtime `Cargo.toml` includes:
```toml
# [dependencies]
# pallet-scheduler = { git = "https://github.com/paritytech/substrate", branch = "polkadot-v1.0.0", default-features = false }
# pallet-preimage = { git = "https://github.com/paritytech/substrate", branch = "polkadot-v1.0.0", default-features = false } # Optional
# pallet-democracy = { git = "https://github.com/paritytech/substrate", branch = "polkadot-v1.0.0", default-features = false }
# pallet-collective = { git = "https://github.com/paritytech/substrate", branch = "polkadot-v1.0.0", default-features = false }
# pallet-elections-phragmen = { git = "https://github.com/paritytech/substrate", branch = "polkadot-v1.0.0", default-features = false }
# pallet-treasury = { git = "https://github.com/paritytech/substrate", branch = "polkadot-v1.0.0", default-features = false }

# In [features] std section, ensure these pallets' "std" features are also enabled.
```

## 3. `construct_runtime!` Macro

Add these pallets to `construct_runtime!`:
```rust
// construct_runtime!(
//     pub enum Runtime where ... {
//         // ... other pallets ...
//         Scheduler: pallet_scheduler::{Pallet, Call, Storage, Event<T>},
//         Preimage: pallet_preimage::{Pallet, Call, Storage, Event<T>}, // Optional
//         Democracy: pallet_democracy::{Pallet, Call, Storage, Config<T>, Event<T>},
//         Council: pallet_collective::<Instance1>::{Pallet, Call, Storage, Origin<T>, Event<T>, Config<T, Instance1>},
//         Elections: pallet_elections_phragmen::{Pallet, Call, Storage, Event<T>, Config<T>},
//         Treasury: pallet_treasury::{Pallet, Call, Storage, Config<T>, Event<T>},
//     }
// );
```
*(Define `OriginCaller` for `PalletsOrigin` in `pallet_scheduler::Config` based on this).*

## 4. Runtime Configuration (`impl Config for Runtime`)

### a. `pallet_scheduler::Config`
```rust
// parameter_types! {
//    pub const MaxScheduledPerBlock: u32 = 50;
//    // NoPreimagePostponement should be Some if pallet-preimage is used, None otherwise.
//    pub const NoPreimagePostponement: Option<BlockNumber> = Some(10 * MINUTES); // e.g. 10 minutes
//}
// impl pallet_scheduler::Config for Runtime {
//    type RuntimeEvent = RuntimeEvent;
//    type RuntimeOrigin = RuntimeOrigin; // Your runtime's aggregate origin type
//    type PalletsOrigin = OriginCaller; // Generated by construct_runtime
//    type RuntimeCall = RuntimeCall;   // Your runtime's aggregate call type
//    type MaximumWeight = RuntimeBlockWeights::get().max_block; // From frame_system::Config
//    type ScheduleOrigin = EnsureRoot<AccountId>; // Or Council.EnsureProportionMoreThan(1,2)
//    type MaxScheduledPerBlock = MaxScheduledPerBlock;
//    type WeightInfo = pallet_scheduler::weights::SubstrateWeight<Runtime>;
//    type OriginPrivilegeCmp = frame_support::traits::EqualPrivilegeOnly; // Standard
//    type Preimages = Preimage; // Integrate with pallet-preimage
//}
```

### b. `pallet_preimage::Config` (If used)
```rust
// parameter_types! {
//    pub const PreimageMaxSize: u32 = 4096 * 1024; // Max preimage size in bytes
//    pub const PreimageBaseDeposit: Balance = 1 * PTCN; // Base deposit for storing a preimage
//    pub const PreimageByteDeposit: Balance = 1 * (PTCN / 1_000_000); // Cost per byte
//}
// impl pallet_preimage::Config for Runtime {
//    type RuntimeEvent = RuntimeEvent;
//    type WeightInfo = pallet_preimage::weights::SubstrateWeight<Runtime>;
//    type Currency = Balances; // For deposits
//    type ManagerOrigin = EnsureRoot<AccountId>; // Who can clear stale preimages
//    type Consideration = (); // No additional consideration for preimage deposits
//}
```

### c. `pallet_democracy::Config`
```rust
// type CouncilCollective = pallet_collective::Instance1; // Define instance for clarity
// parameter_types! {
//    pub const LaunchPeriod: BlockNumber = 2 * DAYS;
//    pub const VotingPeriod: BlockNumber = 10 * DAYS;
//    pub const FastTrackVotingPeriod: BlockNumber = 3 * HOURS;
//    pub const MinimumDeposit: Balance = 100 * PTCN;
//    pub const EnactmentPeriod: BlockNumber = 2 * DAYS;
//    pub const CooloffPeriod: BlockNumber = 7 * DAYS;
//    pub const MaxVotes: u32 = 100;
//    pub const MaxProposals: u32 = 100;
//    // PreimageByteDeposit is now sourced from pallet_preimage if used.
//}
// impl pallet_democracy::Config for Runtime {
//    type RuntimeEvent = RuntimeEvent;
//    type Currency = Balances;
//    type Proposal = RuntimeCall;
//    type Scheduler = Scheduler;
//    type PalletsOrigin = OriginCaller;
//    type Preimages = Preimage; // Integrate with pallet-preimage

//    // Origins for Democracy actions
//    type SubmitOrigin = EnsureSigned<AccountId>;
//    type ExternalOrigin = pallet_collective::EnsureProportionMoreThan<AccountId, CouncilCollective, 1, 2>; // Council majority
//    type ExternalMajorityOrigin = pallet_collective::EnsureProportionMoreThan<AccountId, CouncilCollective, 3, 5>; // Council 3/5
//    type ExternalDefaultOrigin = pallet_collective::EnsureProportionMoreThan<AccountId, CouncilCollective, 1, 2>; // Council majority
//    type FastTrackOrigin = pallet_collective::EnsureProportionMoreThan<AccountId, CouncilCollective, 2, 3>; // Council 2/3 for fast-track
//    type InstantOrigin = pallet_collective::EnsureProportionAtLeast<AccountId, CouncilCollective, 1, 1>; // Unanimous Council for instant
//    type CancellationOrigin = pallet_collective::EnsureProportionMoreThan<AccountId, CouncilCollective, 1, 2>; // Council majority to cancel
//    type CancelProposalOrigin = EnsureRoot<AccountId>; // Or Council
//    type BlacklistOrigin = EnsureRoot<AccountId>; // Or Council to blacklist proposals/proposers
//    type VetoOrigin = pallet_collective::EnsureMember<AccountId, CouncilCollective>; // Any single council member can veto

//    // Parameters
//    type CooloffPeriod = CooloffPeriod;
//    type EnactmentPeriod = EnactmentPeriod;
//    type LaunchPeriod = LaunchPeriod;
//    type MinimumDeposit = MinimumDeposit;
//    type VotingPeriod = VotingPeriod;
//    type FastTrackVotingPeriod = FastTrackVotingPeriod;
//    type VoteLockingPeriod = EnactmentPeriod;
//    type MaxVotes = MaxVotes;
//    type MaxProposals = MaxProposals;
//    type WeightInfo = pallet_democracy::weights::SubstrateWeight<Runtime>;
//    // type PreimageByteDeposit = PreimageByteDeposit; // Sourced from pallet_preimage
//    type OperationalPreimageOrigin = pallet_collective::EnsureMember<AccountId, CouncilCollective>;
//    type Slash = Treasury; // Send proposal bond slash to treasury
//}
```

### d. `pallet_collective::Config` (Instance1: TechnicalCouncil)
```rust
// type CouncilCollective = pallet_collective::Instance1; // Already defined or ensure it's clear
// parameter_types! {
//    pub const CouncilMotionDuration: BlockNumber = 5 * DAYS;
//    pub const CouncilMaxProposals: u32 = 25;
//    pub const CouncilMaxMembers: u32 = 7;
//}
// impl pallet_collective::Config<CouncilCollective> for Runtime {
//    type RuntimeOrigin = RuntimeOrigin;
//    type Proposal = RuntimeCall;
//    type RuntimeEvent = RuntimeEvent;
//    type MotionDuration = CouncilMotionDuration;
//    type MaxProposals = CouncilMaxProposals;
//    type MaxMembers = CouncilMaxMembers;
//    type DefaultVote = pallet_collective::PrimeDefaultVote;
//    type WeightInfo = pallet_collective::weights::SubstrateWeight<Runtime>;
//    type SetMembersOrigin = EnsureRoot<AccountId>; // Who can initially set council members if not using elections
//}
```

### e. `pallet_elections_phragmen::Config` (For Council Elections)
```rust
// parameter_types! {
//    pub const TermDuration: BlockNumber = 7 * DAYS;
//    pub const DesiredMembers: u32 = CouncilMaxMembers::get(); // From collective config
//    pub const DesiredRunnersUp: u32 = 5;
//    pub const CandidacyBond: Balance = 500 * PTCN;
//    pub const VotingBondBase: Balance = 50 * PTCN;
//    pub const VotingBondFactor: Balance = 10 * PTCN;
//    pub const ElectionsPhragmenPalletId: LockIdentifier = *b"phrelect";
//    pub const MaxCandidates: u32 = 50;
//    pub const MaxVoters: u32 = 500;
//}
// impl pallet_elections_phragmen::Config for Runtime {
//    type RuntimeEvent = RuntimeEvent;
//    type PalletId = ElectionsPhragmenPalletId;
//    type Currency = Balances;
//    type ChangeMembers = Council; // This is how elections update the council
//    type InitializeMembers = Council; // On genesis, initialize council members via elections
//    type WeightInfo = pallet_elections_phragmen::weights::SubstrateWeight<Runtime>;
//    type MaxCandidates = MaxCandidates;
//    type MaxVoters = MaxVoters;
//    type MaxVotesPerVoter = ConstU32<16>; // Max nominations a voter can make
//    type CandidacyBond = CandidacyBond;
//    type VotingBondBase = VotingBondBase;
//    type VotingBondFactor = VotingBondFactor;
//    type LoserCandidateDelta = ();
//    type KickedMember = ();
//    type DesiredMembers = DesiredMembers;
//    type DesiredRunnersUp = DesiredRunnersUp;
//    type TermDuration = TermDuration;
//    // DataProvider: This is crucial. It provides the list of voters and their stakes.
//    // For a chain with pallet-staking, this would typically be pallet_staking::Pallet<Runtime>.
//    // If staking is not used for voting weight, a custom provider is needed.
//    type DataProvider = Staking; // Assuming pallet-staking provides voter data.
//    type VoterSnapshotPerBlock = ConstU32<10_000>; // Adjust based on expected voters
//}
```

### f. `pallet_treasury::Config`
```rust
// parameter_types! {
//    pub const ProposalBond: Permill = Permill::from_percent(5);
//    pub const ProposalBondMinimum: Balance = 50 * PTCN;
//    pub const ProposalBondMaximum: Option<Balance> = None;
//    pub const SpendPeriod: BlockNumber = 7 * DAYS;
//    pub const Burn: Permill = Permill::from_percent(0); // No burn for now
//    pub const TreasuryPalletId: PalletId = PalletId(*b"pytrsry"); // Corrected: PalletId needs `*b"py/trsry"` format
//    pub const MaxApprovals: u32 = 100;
//    pub const PayoutSpendPeriod: BlockNumber = 1 * DAYS; // Example: Time for payouts to be claimed
//}
// impl pallet_treasury::Config for Runtime {
//    type PalletId = TreasuryPalletId; // Should be PalletId(*b"py/trsry") format
//    type Currency = Balances;
//    type ApproveOrigin = pallet_collective::EnsureProportionMoreThan<AccountId, CouncilCollective, 1, 2>; // Council majority
//    type RejectOrigin = pallet_collective::EnsureProportionMoreThan<AccountId, CouncilCollective, 1, 3>;  // Council 1/3 to reject (or majority)
//    type RuntimeEvent = RuntimeEvent;
//    type OnSlash = Treasury;
//    type ProposalBond = ProposalBond;
//    type ProposalBondMinimum = ProposalBondMinimum;
//    type ProposalBondMaximum = ProposalBondMaximum;
//    type SpendPeriod = SpendPeriod; // How often the pallet tries to spend its budget.
//    type Burn = Burn;
//    type BurnDestination = ();
//    type SpendFunds = ();
//    type WeightInfo = pallet_treasury::weights::SubstrateWeight<Runtime>;
//    type MaxApprovals = MaxApprovals;
//    // SpendOrigin: Who can authorize spending. For Treasury, this is usually the pallet itself,
//    // as proposals are approved by ApproveOrigin and then dispatched by the pallet.
//    // `frame_support::traits::NeverEnsureOrigin` is often used if no direct extrinsic initiates spending.
//    type SpendOrigin = frame_support::traits::NeverEnsureOrigin<Balance>;
//    // PayoutSpendPeriod: Time given for a beneficiary to claim a payout. (This might be a new constant)
//    // If your version of pallet-treasury doesn't have PayoutSpendPeriod, remove it.
//    // type PayoutSpendPeriod = PayoutSpendPeriod;
//}
```
*(Note: `TreasuryPalletId` should be `PalletId(*b"py/trsry")` using 8 chars. `DAYS`, `HOURS`, `MINUTES` need to be defined based on `MILLISECS_PER_BLOCK`).*

## 5. Genesis Configuration (`chain_spec.rs`)

*   **`pallet_collective` (Instance1: TechnicalCouncil):**
    *   Set initial `members` (e.g., Alice's AccountId, Bob's AccountId).
    *   `phantom: core::marker::PhantomData`.
*   **`pallet_elections_phragmen` (if `InitializeMembers` is used by Council):**
    *   Can be initialized with initial candidates/members if `DataProvider` doesn't source them from `pallet-staking` at genesis, or if `pallet-staking` is also being set up with genesis validators who should be council members.
*   **`pallet_democracy`:**
    *   No specific genesis config usually required beyond preimages if any proposals are launched at genesis.
*   **`pallet_treasury`:**
    *   The Treasury account (derived from `TreasuryPalletId`) can be endowed with initial funds via `pallet_balances` genesis config.

This recipe provides a comprehensive guide. Constants related to time (`LaunchPeriod`, `VotingPeriod`, `TermDuration`, `SpendPeriod`) and monetary amounts (`MinimumDeposit`, `CandidacyBond`) need careful calibration based on the chain's tokenomics and desired governance dynamics. The origins for various actions in `pallet-democracy` are critical for defining the power balance between general token holders and the council.
Ensure `OriginCaller` is correctly derived from `construct_runtime` for `PalletsOrigin`.
The `DataProvider` in `pallet_elections_phragmen` is a key decision: if it's `Staking`, then stakers' data is used. If not, you need a custom implementation or another source.
The `SetMembersOrigin` for `pallet_collective` allows setting initial members if not using elections at genesis.
This is a good set of configurations.
```
